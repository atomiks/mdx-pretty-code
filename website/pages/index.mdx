import {Layout} from '../components/Layout';
export default Layout;

## What's this?

This package is a Remark plugin that provides beautiful syntax highlighting for
your MDX docs. It has advantages over other solutions such as Prism.
[View on GitHub](https://github.com/atomiks/mdx-pretty-code).

### VS Code's highlighting

Leverage the accuracy of VS Code's syntax highlighting engine and the popularity
of its themes ecosystem, powered by [Shiki](https://github.com/shikijs/shiki).
No missing tokens or unexpected broken syntax highlighting.

```js
import Document, {Html, Head, Main, NextScript} from 'next/document';

// ðŸ”¥ Super granular and accurate highlighting
export default class MyDocument extends Document {
  static async getInitialProps(ctx) {
    const initialProps = await Document.getInitialProps(ctx);
    return {...initialProps};
  }

  render() {
    return (
      <Html>
        <Head />
        <body className="bg-zinc-800 text-zinc-200">
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}
```

> The theme is [Moonlight II](https://github.com/atomiks/moonlight-vscode-theme)
> with a custom background color.

### There's no runtime or bundle size cost

Shiki does its highlighting at build-time â€” there's no perf hit caused by
runtime syntax highlighting or kilobytes of library code sent over the wire on
the client. Your docs will be lightning fast.

### Line numbers and line highlighting are supported

```js {4}
import {useFloating} from '@floating-ui/react-dom';

function MyComponent() {
  const {x, y, reference, floating} = useFloating();

  return (
    <>
      <div ref={reference} />
      <div ref={floating} />
    </>
  );
}
```

### Word highlighting too

```js /reference/
import {useFloating} from '@floating-ui/react-dom';

function MyComponent() {
  const {x, y, reference, floating} = useFloating();

  return (
    <>
      <div ref={reference} />
      <div ref={floating} />
    </>
  );
}
```

### Even inline code!

The result of `[1, 2, 3].join('-'){:js}` is `'1-2-3'{:js}`.

#### Context-aware inline code

For instance, if you had the following code block:

```js
function getStringLength(str) {
  return str.length;
}
```

When we refer to `getStringLength{:.entity.name.function}` as a plain variable,
we can color it as a function. Same with `function{:.keyword}`, or
`str{:.variable.parameter}` vs. `str{:.variable.other.object}`, etc. This allows
you to semantically tie inline code with the nearest code block it's referring
to.

### Code blocks are unstyled

No need to fight CSS rules, build the look from scratch. We recommend the
following styles though as a base though:

```css
pre > code {
  display: grid;
}
```

This allows line highlighting to span the width of a horizontally-scrollable
code block on small viewport widths.

## Installation

Install via your terminal:

```shell
npm install @atomiks/mdx-pretty-code shiki
```

## Usage

```js
import {createRemarkPlugin} from '@atomiks/mdx-pretty-code';
import fs from 'fs';

const prettyCode = createRemarkPlugin({
  shikiOptions: {
    // Use one of shiki's packaged themes
    theme: JSON.parse(
      fs.readFileSync(
        require.resolve('./node_modules/shiki/themes/one-dark-pro.json'),
        'utf-8'
      )
    ),

    // Or your own JSON file
    theme: JSON.parse(
      fs.readFileSync(require.resolve('./themes/dark.json'), 'utf-8')
    ),
  },
  onVisitLine(element) {
    // In `display: grid` mode, ensure empty lines do not collapse
    // in height and copy/pasting preserves newlines.
    if (element.textContent === '') {
      element.textContent = ' ';
    }
  },
  // Feel free to add classNames that suit your app.
  // You can also edit `node.style` inline styles directly.
  onVisitHighlightedLine(element) {
    element.className += ' line--highlighted';
  },
  onVisitHighlightedWord(element) {
    element.className = 'word';
  },
});
```

Then pass it to your MDX loader's `remarkPlugins{:.meta.object-literal.key}`
option. For instance, using Next.js:

```js {4}
const withMDX = require('@next/mdx')({
  extension: /\.mdx?$/,
  options: {
    remarkPlugins: [prettyCode],
    rehypePlugins: [],
  },
});
```

### Meta strings

Code blocks are configured via the meta string on the top codeblock fence.

#### Highlight lines

Place a numeric range inside `{}`.

````md
```js {1-3,4}

```
````

#### Highlight words

Literal text, like a regex. Note regex itself is not yet supported.

````md
```js /carrot/

```
````

Highlight only the third to fifth instances of `carrot`. Any numeric range can
be placed after the last `/`.

````md
```js /carrot/3-5

```
````

#### Highlight inline code

Append `{:lang}â€Ž` (e.g. `{:js}â€Ž`) to the end of inline code to highlight it like
a regular code block.

```md
This is an array `[1, 2, 3]{:js}` of numbers 1 through 3.
```

#### Highlight plain text

Append `{:.token}â€Ž` to the end of the inline code to highlight it based on a
token specified in your VS Code theme. Tokens start with a `.` to differentiate
them from a language.

```md
The name of the function is `getStringLength{:.entity.name.function}`.
```

In the components prop passed to `<MDXProvider />{:js}`, modify
`span{:.entity.name.function}` like so:

```js
const mdxComponents = {
  span(props) {
    if (props['data-mdx-pretty-code'] != null) {
      return (
        <code
          data-theme={props['data-theme']}
          style={{color: props['data-color']}}
        >
          {props.children.props.children}
        </code>
      );
    }

    return <span {...props} />;
  },
};
```

You can create a map of tokens to shorten this usage throughout your docs:

```js
createRemarkPlugin({
  // ...
  tokensMap: {
    fn: 'entity.name.function',
  },
});
```

```md
The name of the function is `getStringLength{:.fn}`.
```

### Multiple themes (dark/light mode)

Because Shiki generates themes at build time, client-side theme switching
support is not built in. There are two popular options for supporting something
like Dark Mode with Shiki. See the
[Shiki docs](https://github.com/shikijs/shiki/blob/main/docs/themes.md#dark-mode-support)
for more info.

Pass your themes to `shikiOptions.theme{:.meta.object-literal.key}`, where the
keys represent the color mode:

```js
createRemarkPlugin({
  shikiOptions: {
    theme: {
      dark: JSON.parse(
        fs.readFileSync(require.resolve('./themes/dark.json'), 'utf-8')
      ),
      light: JSON.parse(
        fs.readFileSync(require.resolve('./themes/light.json'), 'utf-8')
      ),
    },
  },
});
```

The `<code>{:html}` elements and the inline code
`<span data-mdx-pretty-code>{:html}` wrappers will have a data attribute
`data-theme="[key]"`, e.g `data-theme="light"`.

Now, you can use CSS to display the desired theme:

```css
@media (prefers-color-scheme: dark) {
  [data-theme='light'] {
    display: none;
  }
}

@media (prefers-color-scheme: light), (prefers-color-scheme: no-preference) {
  [data-theme='dark'] {
    display: none;
  }
}
```

### Line numbers

If you're wondering how to add line numbers, you can use CSS counters.

```css
code {
  counter-reset: line;
}

code > .line::before {
  counter-increment: line;
  content: counter(line);

  /* Other styling */
  display: inline-block;
  width: 1rem;
  margin-right: 2rem;
  text-align: right;
  color: gray;
}
```

## Sanitizing

All HTML is sanitized via
[sanitize-html](https://www.npmjs.com/package/sanitize-html). To configure the
sanitizing options, pass `sanitizeOptions{:.meta.object-literal.key}` to
`createRemarkPlugin(){:js}`, which is 1:1 with its API.

## License

MIT â€¢ [View on GitHub](https://github.com/atomiks/mdx-pretty-code)
